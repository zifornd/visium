---
title: "Quality control"
author: "Ben Southgate"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: cosmo
    highlight: textmate
    df_print: paged
editor_options:
  chunk_output_type: console
---
  
## Setup
  
Set chunk options:
  
```{r}
knitr::opts_chunk$set(echo = TRUE, dev = "png", fig.align = "center")
```

Set library path:
  
```{r}
.libPaths(new = "/sbgenomics/project-files/library")
```

Load Bioconductor packages:
  
```{r, message = FALSE, warning = FALSE}
library(scater)
library(scran)
library(scuttle)
library(Seurat)
```

Load CRAN packages:
  
```{r, message = FALSE, warning = FALSE}
library(patchwork)
library(ggplot2)
library(dplyr)
library(reshape2)
```

Source user-defined functions:

```{r}
source("scripts/loadInSpatial.R")
source("scripts/plotQC.R")
source("scripts/filterCells.R")
```

Enable multicore parallel evaluation:
  
```{r, message = FALSE, warning = FALSE}
library(BiocParallel)

BPP <- MulticoreParam(
  workers = 6,
  stop.on.error = TRUE,
  RNGseed = 0304
)
```

## Processing

Read experiment object:
  
```{r}
seurat <- readRDS("/sbgenomics/output-files/01-data-loading.rds")
```

Read in metrics csv:

```{r}
metrics <- read.csv("/sbgenomics/output-files/metrics.csv")
```


### QC Metrics

Combined QC metrics for visualization:

```{r}
combinedQC <- collectQC(seurat)
combinedQC$Slide <- as.character(sapply(combinedQC$Image, function(x) {unlist(strsplit(x, "_"))[[1]]}))
```

#### nCounts

Vln nCounts (sum):

```{r}
ncount_vln <- violingg(combinedQC, ylab = "nCount_Spatial", colour_by = "Sample", show_median = T)

ncount_vln_group <- violingg(combinedQC, ylab = "nCount_Spatial", colour_by = "Group", show_median = T)

ncount_vln_slide <- violingg(combinedQC, ylab = "nCount_Spatial", colour_by = "Slide", show_median = T)

ncount_vln_area <- violingg(combinedQC, ylab = "nCount_Spatial", colour_by = "Area", show_median = T)
```

Plot Vln ncounts wrapped:

```{r, fig.width = 10, fig.height = 8}
wrap_plots(ncount_vln,
           ncount_vln_group,
           ncount_vln_slide,
           ncount_vln_area)
```

Image map nCounts:

```{r, message = FALSE, warning = FALSE}
spatialPlots <- lapply(names(seurat), function(x, seuratList) { 
  SpatialFeaturePlot(seuratList[[x]], features = "nCount_Spatial") + 
    theme(legend.position = "right") + labs(title=x)
  }, seuratList = seurat)
```

```{r, message = FALSE, warning = FALSE, fig.width = 15, fig.height = 20}
wrap_plots(spatialPlots, nrow = 4)
```

#### nFeatures

Vln nFeatures (detected):

```{r}
nfeature_vln <- violingg(combinedQC, ylab = "nFeature_Spatial", colour_by = "Sample", show_median = T)

nfeature_vln_group <- violingg(combinedQC, ylab = "nFeature_Spatial", colour_by = "Group", show_median = T)

nfeature_vln_slide <- violingg(combinedQC, ylab = "nFeature_Spatial", colour_by = "Slide", show_median = T)

nfeature_vln_area <- violingg(combinedQC, ylab = "nFeature_Spatial", colour_by = "Area", show_median = T)
```

Plot combined nFeatures plots:

```{r, fig.width = 10, fig.height = 8}
wrap_plots(nfeature_vln,
           nfeature_vln_group,
           nfeature_vln_slide,
           nfeature_vln_area)
```

Image map nFeatures:

```{r, message = FALSE, warning = FALSE}
spatialPlots <- lapply(names(seurat), function(x, seuratList) { 
  SpatialFeaturePlot(seuratList[[x]], features = "nFeature_Spatial") + 
    theme(legend.position = "right") + labs(title=x)
  }, seuratList = seurat)
```

```{r, message = FALSE, warning = FALSE, fig.width = 15, fig.height = 20}
wrap_plots(spatialPlots, nrow = 4)
```


#### Metrics plots

Sequencing:

```{r}
seqplot_total1 <- barplotgg(metrics, ylab = "Number.of.Reads", xlab = "Sample.ID", colour_by = "Sample.ID")

seqplot_total2 <- barplotgg(metrics, ylab = "Valid.Barcodes", xlab = "Sample.ID", colour_by = "Sample.ID")

seqplot_total3 <- barplotgg(metrics, ylab = "Valid.UMIs", xlab = "Sample.ID", colour_by = "Sample.ID")

seqplot_total4 <- barplotgg(metrics, ylab = "Q30.Bases.in.Barcode", xlab = "Sample.ID", colour_by = "Sample.ID")

seqplot_total5 <- barplotgg(metrics, ylab = "Q30.Bases.in.Probe.Read", xlab = "Sample.ID", colour_by = "Sample.ID")

seqplot_total6 <- barplotgg(metrics, ylab = "Q30.Bases.in.UMI", xlab = "Sample.ID", colour_by = "Sample.ID")
```

Plot all Sequencing:

```{r, fig.width = 12, fig.height = 8}
wrap_plots(seqplot_total1,
           seqplot_total2,
           seqplot_total3,
           seqplot_total4,
           seqplot_total5,
           seqplot_total6)
```

Melt data frame of Sequencing % metrics and include in single plot:

```{r}
seq_metr <- metrics[,c("Sample.ID","Valid.Barcodes", "Valid.UMIs", "Q30.Bases.in.Barcode", "Q30.Bases.in.Probe.Read", "Q30.Bases.in.UMI")]
seq_metr <- melt(seq_metr)
seq_metr$QC <- paste0(seq_metr$variable,".",seq_metr$Sample.ID)
seq_metr$Percentage <- seq_metr$value

# does not look great
seqplot_combined <- barplotgg(seq_metr, ylab = "Percentage", xlab = "QC" , colour_by = "Sample.ID")
```

Violin plot may be more useful to show all metrics across all samples:

```{r}
seq_metr <- metrics[,c("Sample.ID","Valid.Barcodes", "Valid.UMIs", "Q30.Bases.in.Barcode", "Q30.Bases.in.Probe.Read", "Q30.Bases.in.UMI")]
seq_metr <- melt(seq_metr)
seq_metr$Percentage <- seq_metr$value
seq_metr$QC <- seq_metr$variable
```

```{r , fig.width = 4, fig.height = 4}
violingg(seq_metr, ylab = "Percentage", xlab = "QC", colour_by = "Sample.ID", show_median = T)
```

```{r , fig.width = 4, fig.height = 4}
violingg(seq_metr, ylab = "Percentage", xlab = "QC", colour_by = "Sample.ID", show_median = T, ylim = c(0,1))
```

Mapping:

```{r}
mappingplot1 <- barplotgg(metrics, ylab = "Reads.Mapped.to.Probe.Set", xlab = "Sample.ID", colour_by = "Sample.ID")
```

Add warning metric from 10x html to metric dataframe:

```{r}
metrics$Warning <- ifelse(metrics$Reads.Mapped.Confidently.to.Probe.Set <= 0.5, "Red","Green") 

metrics$Warning <- factor(metrics$Warning, levels = c("Red", "Green"))
```

```{r}
mappingplot2 <- barplotgg(metrics, ylab = "Reads.Mapped.Confidently.to.Probe.Set", xlab = "Sample.ID", colour_by = "Sample.ID")

mappingplot3 <- barplotgg(metrics, ylab = "Reads.Mapped.Confidently.to.the.Filtered.Probe.Set", xlab = "Sample.ID", colour_by = "Sample.ID", ylim=c(0,1))

mappingplot4 <- barplotgg(metrics, ylab = "Reads.Mapped.Confidently.to.Probe.Set", xlab = "Sample.ID", colour_by = "Warning")

```

Plot all mapping:

```{r, fig.width = 8, fig.height = 8}
wrap_plots(mappingplot1, 
           mappingplot2,
           mappingplot3,
           mappingplot4)

```

Violin plot may be more useful to show all metrics across all samples:

```{r, message = FALSE, warning = FALSE}
map_metr <- metrics[,c("Sample.ID","Reads.Mapped.to.Probe.Set", "Reads.Mapped.Confidently.to.Probe.Set", "Reads.Mapped.Confidently.to.the.Filtered.Probe.Set", "Warning")]
map_metr <- melt(map_metr)
map_metr$Percentage <- map_metr$value
map_metr$QC <- map_metr$variable
```

```{r , fig.width = 4, fig.height = 4}
violingg(map_metr, ylab = "Percentage", xlab = "QC", colour_by = "Sample.ID", show_median = T)
```

```{r , fig.width = 4, fig.height = 4}
violingg(map_metr, ylab = "Percentage", xlab = "QC", colour_by = "Warning", show_median = T)

```

Spots:

```{r}
spotplot_total1 <- barplotgg(metrics, ylab = "Number.of.Spots.Under.Tissue", xlab = "Sample.ID", colour_by = "Sample.ID")

spotplot_total2 <- barplotgg(metrics, ylab = "Mean.Reads.per.Spot", xlab = "Sample.ID", colour_by = "Sample.ID")

spotplot_total3 <- barplotgg(metrics, ylab = "Median.Genes.per.Spot", xlab = "Sample.ID", colour_by = "Sample.ID")
```

Plot all spot:

```{r, fig.width = 12, fig.height = 4}
wrap_plots(spotplot_total1,
           spotplot_total2,
           spotplot_total3)
```


### Cell Filtering

Identify low-quality cells based on frequently used QC metrics:
Look at ranges of x y values for easier estimation of coordinates

e.g. image at index 1

```{r}
image_key <- seurat[[1]]@images[[1]]@key
  
# fetch xy axis data frame
spatial_df <- FetchData(seurat[[1]], vars = c(paste0(image_key, "imagerow"), 
                                         paste0(image_key, "imagecol")))

print(c("Y axis range:", range(spatial_df[,1])))
print(c("X axis range:",range(spatial_df[,2])))
```

Filter out those low quality spots which are located peripherally

```{r}
seurat_1 <- filterByXY(seurat[[1]], x1 = 85.00408692 , x2 = 520 , 
                             y1 = 53.49836036, y2 = 513.829758624)
```

Show which cells have been filtered

```{r}
labels <- SpatialDimPlot(seurat[[1]],cells.highlight = colnames(seurat_1))
```

Plot alongside original UMI count plot

```{r, message = FALSE, warning = FALSE }
counts <- SpatialFeaturePlot(seurat[[1]], features = "nCount_Spatial") + theme(legend.position = "right")
```

Plot together

```{r, fig.width = 6, fig.height = 10}
wrap_plots(counts,
           labels, 
          ncol = 1)
```

Replace old seurat object with new 

```{r}
seurat[[1]] = NULL

seurat[[1]] = seurat_1
```

Remove any low quality samples (e.g. at index 2 and 3)

```{r}
seurat[[2]] = NULL

seurat[[3]] = NULL
```

#### Remove spots with zero counts

SCT transform will complain when attempts to log transform

```{r}
table(seurat[[4]]$nCount_Spatial == 0)
```

Filter out all those with > 0 counts

```{r}
seurat_4 <- seurat[[4]][,seurat[[4]]$nCount_Spatial > 0]
```

Show which cells/spots have been filtered

```{r}
labels <- SpatialDimPlot(seurat[[4]],cells.highlight = colnames(seurat_4))
```

Plot alongside original UMI count plot

```{r, message = FALSE, warning = FALSE}
counts <- SpatialFeaturePlot(seurat[[4]], features = "nCount_Spatial") + theme(legend.position = "right")
```

Plot together

```{r, fig.width = 6, fig.height = 10}
wrap_plots(counts,
           labels, 
          ncol = 1)
```

Replace old seurat object with new 

```{r}
seurat[[4]] = NULL

seurat[[4]] = seurat_4
```


## Output

Save experiment object:

```{r}
saveRDS(seurat, file = "/sbgenomics/output-files/02-quality-control.rds")
```  

Print session information:
  
```{r}
sessionInfo()
```
