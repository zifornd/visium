---
title: "Merge samples"
params:
  elbow_range: 
    - "1:20"
  cluster:
    - "res.0.3"
  cluster.plot: ["res.0.2", "res.0.3"]
  n.neighbors:
    - 30
  min.dist:
    - 0.3
  perplexity:
    - "N^1/2"
  plot_width:
    - 5
  plot_height:
    - 4
---

# Setup

### Parameters

@tbl-params Parameter description

```{r}
#| code-fold: true
#| label: tbl-params
#| tbl-cap: Description of paramaters used in notebook.

par <- list(

list(
Parameter = "elbow_range",
Value = params$elbow_range,
Description = "Number of PCs used for reduced dimension analysis."
),
list(
Parameter = "cluster",
Value = params$cluster,
Description = "Chosen res params for clustering."
),
list(
Parameter = "cluster.plot",
Value = params$cluster.plot,
Description = "Chosen res params to complete spatial plot downstream."
),
list(
Parameter = "n.neighbors",
Value = params$n.neighbors,
Description = "Chosen n.neighbors param for UMAP."
),
list(
Parameter = "min.dist",
Value = params$min.dist,
Description = "Chosen min.dist param for UMAP."
),
list(
Parameter = "perplexity",
Value = params$perplexity,
Description = "Chosen perplexity param for TSNE."
)
)

par <- jsonlite::toJSON(par, pretty = TRUE)

knitr::kable(jsonlite::fromJSON(par))
```

::: callout-tip
You can supply these paramaters upon render.
:::

### Dependencies

Add child documents

```{r}
#| child = "analysis/big-data.qmd"
```

Restore project dependencies:

```{r}
#renv::restore()
```

Load Bioconductor packages:

```{r}
#| message: false
#| warning: false

library(Seurat)
```

Load CRAN packages:

```{r}
#| message: false
#| warning: false

library(patchwork)
library(ggplot2)
library(dplyr)
library(reshape2)
library(viridis)
library(clustree)
```

Source user-defined functions:

```{r}
source("scripts/loadInSpatial.R")
source("scripts/normalise.R")
source("scripts/reduceDims.R")
source("scripts/cluster.R")
```

::: callout-note
Much of the visium quarto workflow include Rscripts which are not part of a external library but are sourced at the start of each workflow. Each script is stored within `scripts/`. Please see the start of each .qmd file for the details of which scripts have been sourced.
:::

# Processing

### Reading in experiment object

We can read in the seurat object that we loaded in from the previous worksheet (See quarto worksheet `05-clustering.qmd` for more details).

```{r}
seurat <- readRDS("output/05-clustering.rds")
```

## Merge samples

Much of this workbook is focused around elements that we have already discussed in previous portions of the visium workflow (see `04-reduced-dimensions.qmd` and `05-clustering.qmd`). The distinction here is that we are merging our samples together into a single seurat object prior to re-running dimensionality reduction and clustering.

As discussed in `03-normalisation.qmd` seurat authors suggest to normalise each sample individually prior to merging as each sample would have a different amount of technical noise.

Please see https://github.com/satijalab/seurat/discussions/4430 for more details.

Below we merge the samples together - this combines them in the simplest of senses by combining count matrices, features, and metadata into a single seurat object. It **does not** complete additional processing on the data.

For more details see https://satijalab.org/seurat/articles/merge_vignette.html

::: callout-note
Removal of known batch effects with seurats `ScaleData` and `vars.to.regress` may be an option for visualisation purposes down stream.
:::

::: callout-note
Another approach is offered by following the alternative `07-integrate-samples.qmd` workflow which does process samples prior to combining.
:::

::: callout-warning
As there are multiple SCT models present within a merged seurat object further processing will need to be completed prior to marker detection (see `08-marker-detection.qmd`)
:::

```{r}
#| message: false
#| warning: false

seurat <- seuratMerge(seurat)
```

## Downstream analysis

Following merging we follow the same analysis as described in `04-reduced-dimensions.qmd` and `05-clustering.qmd.` For more details on these analyses please consult the relevant workflow.

## Dimensionality Reduction

### PCA

It is common practice to perform dimensionality reduction and clustering using the top principal components from principal component analysis (PCA).

Below we perform PCA on the merged seurat object:

```{r}
#| message: false
#| warning: false

seurat <- pca(seurat)
```

### Plot PCAs

Below we plot the first two components of the PCA that we completed on the merged seurat object coloured by group.

```{r}
#| message: false
#| warning: false
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: PCA plot Merged by group.

dimplot(seurat, reduction = "pca", label = FALSE, 
        group.by = "Group", title = "PCA-Merged")
```

Below we plot the first two components of the PCA that we completed on the merged seurat object coloured by `nCount_Spatial`.

@fig-pca-ncount Plot PCA nCount merged

```{r}
#| message: false
#| warning: false
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: PCA plot Merged by nCount.
#| label: fig-pca-ncount

featureplot(seurat, reduction = "pca", label = FALSE, 
            feature = "nCount_Spatial", title = "PCA-Merged")
```

Below we plot the first two components of the PCA that we completed on the merged seurat object coloured by `nFeature_Spatial`.

@fig-pca-nfeature Plot PCA nFeature merged

```{r}
#| message: false
#| warning: false
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: PCA plot Merged by nFeature.
#| label: fig-pca-nfeature

featureplot(seurat, reduction = "pca", label = FALSE, 
            feature = "nFeature_Spatial", title = "PCA-Merged")
```

### Elbow

A simple way to decide how many PCs to use downstream is to generate an Elbow plot by ranking the PCs by % variance that each explains and finding the "elbow" in which variance ceases to decrease. At this elbow the majority true biological signal is captured.

Below we plot the variance of the top components as an elbow plot.

@fig-elbow Elbow plot merged

```{r}
#| message: false
#| warning: false
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: Elbow plot Merged.
#| label: fig-elbow

elbow(seurat, vline1 = 10, vline2 = 20, title = "Elbow-Merged")
```

::: callout-note
Please take the number of PCs (e.g. `1:20`) you want as inferred from inspecting the elbow plot and rerun this workflow with the `elbow_range` parameter reset for your needs. We advice to take a larger PC number than the exact elbow visualised.
:::

Below we take number of PCs from visual inspection defined by the parameter elbow vector:

```{r}
#| warning: false

elbow_vector <- params$elbow_range

print(elbow_vector)
```

And we add that information to the seurat object

```{r}
#| message: false
#| warning: false

seurat$Elbow <- rep(elbow_vector, length(seurat$Sample))
```

### UMAP

Next we take the results from our PCA and feed this into a non-linear dimensionality reduction technique such as UMAP.

Below we explore the parameter space of UMAPs for our merged seurat samples. Remember that `n.neighbors` should be in the range 5 to 50, and `min.dist` sensible values are in the range 0.001 to 0.5.

```{r}
#| label: Explore-Features-UMAP
#| warning: false
#| message: false
#| results: hide

seurat_1 <- umap(seurat, n.neighbors = 30, min.dist = 0.3)

seurat_2 <- umap(seurat, n.neighbors = 5, min.dist = 0.25)

seurat_3 <- umap(seurat, n.neighbors = 10, min.dist = 0.1)

seurat_4 <- umap(seurat, n.neighbors = 20, min.dist = 0.1)

seurat_5 <- umap(seurat, n.neighbors = 10, min.dist = 0.001)
```

@fig-umap-30-03 Plot UMAP n.neighbors = 30, min.dist = 0.3

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: UMAP Merged n.neighbors = 30, min.dist = 0.3.
#| label: fig-umap-30-03

dimplot(seurat_1, reduction = "umap", label = FALSE, 
        group.by = "Group", title = "UMAP-Merged n.neighbors = 30, min.dist = 0.3")
```

@fig-umap-05-025 Plot UMAP n.neighbors = 5, min.dist = 0.25

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: UMAP Merged n.neighbors = 5, min.dist = 0.25.
#| label: fig-umap-05-025

dimplot(seurat_2, reduction = "umap", label = FALSE, 
        group.by = "Group", title = "UMAP-Merged n.neighbors = 5, min.dist = 0.25")
```

@fig-umap-10-01 Plot UMAP n.neighbors = 10, min.dist = 0.1

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: UMAP Merged n.neighbors = 10, min.dist = 0.1.
#| label: fig-umap-10-01

dimplot(seurat_3, reduction = "umap", label = FALSE, 
        group.by = "Group", title = "UMAP-Merged n.neighbors = 10, min.dist = 0.1")
```

@fig-umap-20-01 Plot UMAP n.neighbors = 20, min.dist = 0.1

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: UMAP Merged n.neighbors = 20, min.dist = 0.1.
#| label: fig-umap-20-01

dimplot(seurat_4, reduction = "umap", label = FALSE, 
        group.by = "Group", title = "UMAP-Merged n.neighbors = 20, min.dist = 0.1")
```

@fig-umap-10-0001 Plot UMAP n.neighbors = 10, min.dist = 0.001

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: UMAP Merged n.neighbors = 10, min.dist = 0.001.
#| label: fig-umap-10-0001

dimplot(seurat_5, reduction = "umap", label = FALSE, 
        group.by = "Group", title = "UMAP-Merged n.neighbors = 10, min.dist = 0.001")
```

Clean up workspace

```{r}
rm(seurat_1, seurat_2, seurat_3, seurat_4, seurat_5)

gc()
```

### Plot UMAP

::: callout-note
Please take the values for `n.neighbors` and `min.dist` that are representative across UMAP plots and set them as params.
:::

Below we run UMAP with the paramaters of choice `r paste0("n.neighbors: ", params$n.neighbors, " min.dist: ", params$min.dist)`

```{r}
#| warning: false
#| message: false
#| results: hide

print(paste0("n.neighbors: ", params$n.neighbors))

print(paste0("min.dist: ", params$min.dist))

seurat <- umap(seurat, n.neighbors = params$n.neighbors, 
               min.dist = params$min.dist)
```

Below we plot the merged UMAP.

@fig-umap-chosen Plot UMAP merged

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: TSNE Integrated chosen params.
#| label: fig-umap-chosen


dimplot(seurat, reduction = "umap", label = FALSE, group.by = "Group", 
        title = "UMAP-Merged")
```

As previously discussed it can also be a very useful exploratory data analysis step to look at the UMAP/TSNE coloured by QC values such as overall counts (`nCount_Spatial`) and number of features per spot (`nFeature_Spatial`). The idea here is that a cluster may be driven by a technical reason such as a difference in library size which could be amenable to normalisation approaches - or should be interpreted with caution downstream (some biological regions are also known to reliably have low counts and this may be evident).

Below we plot a UMAP with chosen params coloured by `nCount_Spatial`.

@fig-umap-chosen-ncounts Plot UMAP nCount merged

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: UMAP Merged chosen params nCounts.
#| label: fig-umap-chosen-ncounts

featureplot(seurat, reduction = "umap", label = FALSE, 
            feature = "nCount_Spatial", title = "UMAP-Merged")
```

Below we plot a UMAP with chosen params coloured by `nFeature_Spatial`.

@fig-umap-chosen-nfeature Plot UMAP nFeature merged

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: UMAP Merged chosen params nFeatures.
#| label: fig-umap-chosen-nfeature

featureplot(seurat, reduction = "umap", label = FALSE, 
            feature = "nFeature_Spatial", title = "UMAP-Merged")
```

### TSNE

Due to restrictions on compute time we will only plot a chosen TSNE with `r params$perplexity`.

### Plot TSNE

Below we run TSNE with the paramaters of choice - `r params$perplexity`

```{r}
#| warning: false
#| message: false
#| results: hide

print(paste0("perplexity: ", params$perplexity))

seurat <- tsne(seurat, perplexity = params$perplexity)
```

Below we plot the merged TSNE.

@fig-tsne-chosen Plot TSNE merged

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: TSNE Merged chosen params.
#| label: fig-tsne-chosen

dimplot(seurat, reduction = "tsne", label = FALSE, 
        group.by = "Group", title = "TSNE-Merged")
```

Below we plot a TSNE with chosen params coloured by `nCount_Spatial`.

@fig-tsne-chosen-ncounts Plot TSNE nCount merged

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: TSNE Merged chosen params nCounts.
#| label: fig-tsne-chosen-ncounts

featureplot(seurat, reduction = "tsne", label = FALSE, 
            feature = "nCount_Spatial", title = "TSNE-Merged")
```

Below we plot a TSNE with chosen params coloured by `nFeature_Spatial`.

@fig-tsne-chosen-ncounts Plot TSNE nFeature merged

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr params$plot_height
#| fig-cap: TSNE Merged chosen params nFeatures.
#| label: fig-tsne-chosen-nfeature

featureplot(seurat, reduction = "tsne", label = FALSE, 
            feature = "nFeature_Spatial", title = "TSNE-Merged")
```

## Cluster

The next step in the spatial workflow is to cluster spots to identify anatomically distinct regions across tissue samples - using the graph-based clustering approach (SNN).

Generally speaking we like to keep k.param as Seurat default (\`k.param = 20\`), therefore below we will keep it stable whilst changing the \`resolution\` parameter. We will save the results of this clustering into the seurat object so we can refer to this clustering downstream.

```{r}
#| warning: false
#| message: false
#| results: hide

seurat <- snnCluster(seurat, k.param = 20, resolution = 0.1)

seurat <- snnCluster(seurat, k.param = 20, resolution = 0.2)

seurat <- snnCluster(seurat, k.param = 20, resolution = 0.3)

seurat <- snnCluster(seurat, k.param = 20, resolution = 0.5)

seurat <- snnCluster(seurat, k.param = 20, resolution = 0.6)

seurat <- snnCluster(seurat, k.param = 20, resolution = 0.8)
```

### Plot UMAPS with `k.params 20`

Here we plot using the meta data column name associated with a given resolution.

@fig-kparam-20-res-01 Plot UMAP k.param = 20, resolution = 0.1

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr (params$plot_height + 1)
#| fig-cap: UMAP Merged k.param = 20, resolution = 0.1.
#| label: fig-kparam-20-res-01

dimplot(seurat, reduction = "umap", label = T, 
        group.by = "res.0.1", 
        title = "UMAP-Merged, k.param = 20, resolution = 0.1")
```

@fig-kparam-20-res-02 Plot UMAP k.param = 20, resolution = 0.2

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr (params$plot_height + 1)
#| fig-cap: UMAP Merged k.param = 20, resolution = 0.2.
#| label: fig-kparam-20-res-02

dimplot(seurat, reduction = "umap", label = T, 
        group.by = "res.0.2", 
        title = "UMAP-Merged, k.param = 20, resolution = 0.2")
```

@fig-kparam-20-res-03 Plot UMAP k.param = 20, resolution = 0.3

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr (params$plot_height + 1)
#| fig-cap: UMAP Merged k.param = 20, resolution = 0.3.
#| label: fig-kparam-20-res-03

dimplot(seurat, reduction = "umap", label = T, 
        group.by = "res.0.3", 
        title = "UMAP-Merged, k.param = 20, resolution = 0.3")
```

@fig-kparam-20-res-05 Plot UMAP k.param = 20, resolution = 0.5

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr (params$plot_height + 1)
#| fig-cap: UMAP Merged k.param = 20, resolution = 0.5.
#| label: fig-kparam-20-res-05

dimplot(seurat, reduction = "umap", label = T, 
        group.by = "res.0.5", 
        title = "UMAP-Merged, k.param = 20, resolution = 0.5")
```

@fig-kparam-20-res-06 Plot UMAP k.param = 20, resolution = 0.6

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr (params$plot_height + 1)
#| fig-cap: UMAP Merged k.param = 20, resolution = 0.6.
#| label: fig-kparam-20-res-06

dimplot(seurat, reduction = "umap", label = T, 
        group.by = "res.0.6", 
        title = "UMAP-Merged, k.param = 20, resolution = 0.6")
```

@fig-kparam-20-res-08 Plot UMAP k.param = 20, resolution = 0.8

```{r}
#| fig.width: !expr params$plot_width
#| fig.height: !expr (params$plot_height + 1)
#| fig-cap: UMAP Merged k.param = 20, resolution = 0.8.
#| label: fig-kparam-20-res-08

dimplot(seurat, reduction = "umap", label = T, 
        group.by = "res.0.8", 
        title = "UMAP-Merged, k.param = 20, resolution = 0.8")
```

### Clustering stability

Another way of deciding what resolution to choose is to look at the stability of clusters across different resolution parameters. Below we use the package `clustree` to produce clustering trees to visualise this process.

We complete this process with `k.param = 20` (seurat default)

@fig-clustree Plot clustree

```{r}
#| warning: false
#| message: false
#| fig.width: 10
#| fig.height: 10
#| fig-cap: Clustree dendrogram across chosen k param.
#| label: fig-clustree

clustreeRun(seurat)
```

### Silhouette

There are numerous other quantitative ways to evaluate clustering quality - however the one we use here is the silhouette width metric.

We complete this process with `k.param = 20` (seurat default).

A cell with a large positive width is closer to other cells from the same cluster - compared to cells from different clusters. On the other hand, low or negative widths indicate that cells from - different clusters are not well separated.

```{r}
#| warning: false
#| message: false

silhouettes_1 <- silhouette(seurat, clustername = "res.0.2", sample = "merged")

silhouettes_2 <- silhouette(seurat, clustername = "res.0.3", sample = "merged")

silhouettes_3 <- silhouette(seurat, clustername = "res.0.5", sample = "merged")

silhouettes_4 <- silhouette(seurat, clustername = "res.0.6", sample = "merged")

silhouettes_5 <- silhouette(seurat, clustername = "res.0.8", sample = "merged")
```

Below we plot these scores as boxplots:

```{r}
#| warning: false
#| message: false

silhouette_plots_1 <- plotSil(silhouettes_1, type = "boxplot", title = "res.0.2")

silhouette_plots_2 <- plotSil(silhouettes_2, type = "boxplot", title = "res.0.3")

silhouette_plots_3 <- plotSil(silhouettes_3, type = "boxplot", title = "res.0.5")

silhouette_plots_4 <- plotSil(silhouettes_4, type = "boxplot", title = "res.0.6")

silhouette_plots_5 <- plotSil(silhouettes_5, type = "boxplot", title = "res.0.8")
```

@fig-sil-merged Plot silhouette

```{r}
#| fig.width: 12
#| fig.height: 10
#| fig-cap: Silhouette plots across res params.
#| label: fig-sil-merged

wrap_plots(silhouette_plots_1,
           silhouette_plots_2,
           silhouette_plots_3,
           silhouette_plots_4,
           silhouette_plots_5,
           ncol = 2)
```

Clean up workspace

```{r}
rm(silhouettes_1, silhouettes_2, silhouettes_3, silhouettes_4, silhouettes_5)
gc()
```

### Spatial Clusters

Another important approach for clustering in the context of spatial transcriptomics is to see how this clustering looks when mapped onto our tissue images. By doing this we can see if our clusters relate to biology and whether a given parameter introduces noise (introduces a randomly distributed cluster) or finds a anatomically prescribed region of interest.

Below we will plot two resolutions of interest across our H+E images.

::: callout-note
Please take the two resolution parameters of interest and define them as params for plotting as spatial dimension plots.
:::

```{r}
#| warning: false
#| message: false

sdplot1 <- plotSpatialCluster(seurat, label = TRUE, 
                              label.size = 3, group = params$cluster.plot[[1]])

sdplot2 <- plotSpatialCluster(seurat, label = TRUE, 
                              label.size = 3, group = params$cluster.plot[[2]])
```

@fig-spatial-res1 Plot spatial plot clusters for `r params$cluster.plot[[1]]`

```{r}
#| fig.width: 25
#| fig.height: 10
#| fig-cap: !expr paste0("Spatial plot ", params$cluster.plot[[1]])
#| label: fig-spatial-res1

wrap_plots(sdplot1)
```

@fig-spatial-res2 Plot spatial plot clusters for `r params$cluster.plot[[2]]`

```{r}
#| fig.width: 25
#| fig.height: 10
#| fig-cap: !expr paste0("Spatial plot ", params$cluster.plot[[2]])
#| label: fig-spatial-res2

wrap_plots(sdplot2)
```

### Apply chosen cluster labels

Below we decide on a resolution of choice using a combination of the above 4 approaches (UMAP, cluster tree, silhouette scores, and the spatial distribution of clusters) and apply this label to the seurat meta data column as "Cluster".

```{r}
seurat <- addLabel(seurat, chosenCluster = params$cluster)
```

# Output

Save experiment object:

```{r}
saveRDS(seurat, file = "output/06-merge-samples.rds")
```

Print session information:

<button class="btn btn-primary" data-bs-toggle="collapse" data-bs-target="#BlockName"> Show/Hide </button>  

<div id="BlockName" class="collapse show">  

```{r}
#| code-fold: false
sessionInfo()
```

</div>
