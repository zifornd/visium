---
title: "Quality control"
---

## Setup

```{r, setup, include=FALSE}
# knitr::opts_knit$set(root.dir = "C:/Users/Ben/Documents/GitHub/visium")
```

Restore project dependencies:

```{r}
#renv::restore()
```

Load Bioconductor packages:

```{r}
#| message: false
#| warning: false

library(Seurat)
```

Load CRAN packages:

```{r}
#| message: false
#| warning: false

library(patchwork)
library(ggplot2)
library(dplyr)
library(reshape2)
```

Source user-defined functions:

```{r}
source("scripts/loadInSpatial.R")
source("scripts/plotQC.R")
source("scripts/filterCells.R")
```

## Processing

Read experiment object:

```{r}
seurat <- readRDS("output/01-data-loading.rds")
```

Read in metrics csv:

```{r}
metrics <- read.csv("output/metrics.csv")
```

### QC Metrics

Combine QC metrics for visualization:

```{r}
combinedQC <- collectQC(seurat)
```

#### nCounts

Violin plots for nCounts metric from 10x output (sum in OSCA):

```{r}
meta <- c("Sample", "Group", "Slide", "Area")

vlns <- lapply(meta, function(x, combinedQC, clean_label) {

  violingg(combinedQC, ylab = "nCount_Spatial", colour_by = x, show_median = T, 
           clean = 15, delim = "_", clean_label = clean_label)

  }, combinedQC = combinedQC, clean_label = wrap_label)
```

@fig-ncountsviolin Plot combined nCounts Violin plots:

```{r}
#| fig.width: 10
#| fig.height: 8
#| label: fig-ncountsviolin
#| fig-cap: nCounts across samples labelled by possible confounders.
#| warning: false
#| message: false

wrap_plots(vlns)
```

Image map plots for nCounts:

```{r}
#| message: false
#| warning: false

spatialPlots <- lapply(names(seurat), function(x, seuratList) { 

  SpatialFeaturePlot(seuratList[[x]], features = "nCount_Spatial") + 
    theme(legend.position = "right") + labs(title = x)

  }, seuratList = seurat)
```

@fig-ncountsimage Plot Image map plots for nCounts

```{r}
#| fig.width: 15
#| fig.height: 20
#| label: fig-ncountsimage
#| fig-cap: nCounts across sample images.
#| warning: false
#| message: false

wrap_plots(spatialPlots)
```

#### nFeatures

Violin plots for nFeatures metric from 10x output (detected in OSCA):

```{r}
meta <- c("Sample", "Group", "Slide", "Area")

vlns <- lapply(meta, function(x, combinedQC, clean_label) {

  violingg(combinedQC, ylab = "nFeature_Spatial", colour_by = x, 
           show_median = T, clean = 15, delim = "_", clean_label = clean_label)

  }, combinedQC = combinedQC, clean_label = wrap_label)
```

@fig-nfeaturesviolin Plot combined nFeatures plots:

```{r}
#| fig.width: 10
#| fig.height: 8
#| label: fig-nfeaturesviolin
#| fig-cap: nFeatures across sample images.
#| warning: false
#| message: false

wrap_plots(vlns)
```

@fig-nfeaturesimage Image map nFeatures:

```{r}
#| warning: false
#| message: false

spatialPlots <- lapply(names(seurat), function(x, seuratList) { 

  SpatialFeaturePlot(seuratList[[x]], features = "nFeature_Spatial") +
    theme(legend.position = "right") + labs(title = x)

  }, seuratList = seurat)
```

```{r}
#| fig.width: 15
#| fig.height: 20
#| label: fig-nfeaturesimage
#| fig-cap: nFeatures across sample images.
#| warning: false
#| message: false

wrap_plots(spatialPlots)
```

#### Additional QC Metrics

##### Sequencing:

```{r}
metricscols <- c("Number.of.Reads", "Valid.Barcodes", "Valid.UMIs", 
                 "Q30.Bases.in.Barcode", "Q30.Bases.in.Probe.Read", 
                 "Q30.Bases.in.UMI")

bars <- lapply(metricscols, function(x, metrics, clean_label) {
  
  barplotgg(metrics, ylab = x, xlab = "Sample.ID", colour_by = "Sample.ID", 
            clean = 11, delim = "_", xdelim = ".", ydelim = ".", 
            clean_label = clean_label)

  }, metrics = metrics, clean_label = wrap_label)
```

@fig-qcseq and @fig-qcseqviolin Plot all Sequencing:

```{r}
#| fig.width: 12
#| fig.height: 8
#| label: fig-qcseq
#| fig-cap: Sequencing QC values.

wrap_plots(bars)
```

Summary Violin plot

```{r}
seq_metr <- metrics[,c("Sample.ID","Valid.Barcodes", "Valid.UMIs", 
                       "Q30.Bases.in.Barcode", "Q30.Bases.in.Probe.Read", 
                       "Q30.Bases.in.UMI")]

seq_metr <- melt(seq_metr)

seq_metr$Percentage <- seq_metr$value

seq_metr$QC <- seq_metr$variable
```

```{r}
v1 <- violingg(seq_metr, ylab = "Percentage", xlab = "QC", 
               colour_by = "Sample.ID", show_median = T)

v2 <- violingg(seq_metr, ylab = "Percentage", xlab = "QC", 
               colour_by = "Sample.ID", show_median = T, ylim = c(0,1))
```

```{r}
#| fig.width: 4
#| fig.height: 6
#| label: fig-qcseqviolin
#| fig-cap: Sequencing QC values summary violin.

wrap_plots(v1, v2, nrow = 2)
```

##### Mapping:

```{r}
metricscols <- c("Reads.Mapped.to.Probe.Set", 
                 "Reads.Mapped.Confidently.to.Probe.Set", 
                 "Reads.Mapped.Confidently.to.the.Filtered.Probe.Set")

bars <- lapply(metricscols, function(x, metrics, clean_label) {
  
  barplotgg(metrics, ylab = x, xlab = "Sample.ID", colour_by = "Sample.ID", 
            clean = 15, delim = "_", xdelim = ".", ydelim = ".", 
            clean_label = clean_label)

  }, metrics = metrics, clean_label = wrap_label)
```

Add Warning values if mapping poor

```{r}
metrics$Warning <- ifelse(metrics$Reads.Mapped.Confidently.to.Probe.Set <= 0.5, 
                          "Red","Green") 

metrics$Warning <- factor(metrics$Warning, levels = c("Red", "Green"))

warningplot <- barplotgg(metrics, ylab = "Reads.Mapped.Confidently.to.Probe.Set", 
                         xlab = "Sample.ID", colour_by = "Warning", 
                          clean = 15, delim = "_", xdelim = ".", 
                         ydelim = ".", clean_label = wrap_label)

bars[[4]] <- warningplot
```

@fig-qcmapping and @fig-qcmappingviolin Plot all mapping:

```{r}
#| fig.width: 8
#| fig.height: 6
#| label: fig-qcmapping
#| fig-cap: Mapping QC values.

wrap_plots(bars, nrow = 2)
```

Summary Violin plot

```{r}
#| message: false
#| warning: false
#| label: fig-qcmappingviolin
#| fig-cap: Mapping QC values summary violin.

map_metr <- metrics[,c("Sample.ID","Reads.Mapped.to.Probe.Set", 
                       "Reads.Mapped.Confidently.to.Probe.Set", 
                       "Reads.Mapped.Confidently.to.the.Filtered.Probe.Set", 
                       "Warning")]

map_metr <- melt(map_metr)

map_metr$Percentage <- map_metr$value

map_metr$QC <- map_metr$variable
```

```{r}
v1 <- violingg(map_metr, ylab = "Percentage", xlab = "QC", 
               colour_by = "Sample.ID", show_median = T, clean = 20)

v2 <- violingg(map_metr, ylab = "Percentage", xlab = "QC", 
               colour_by = "Sample.ID", show_median = T, ylim = c(0,1), 
               clean = 20)

v3 <- violingg(map_metr, ylab = "Percentage", xlab = "QC", 
               colour_by = "Warning", show_median = T, clean = 20)
```

With warning label

```{r}
#| fig.width: 8
#| fig.height: 8
#| label: fig-qcmappingwarning
#| fig-cap: Mapping QC values violin with mapping warnings.

wrap_plots(v1, v2, v3, nrow = 2)
```

##### Spots:

```{r}
metricscols <- c("Number.of.Spots.Under.Tissue", "Mean.Reads.per.Spot", 
                 "Median.Genes.per.Spot")

bars <- lapply(metricscols, function(x, metrics, clean_label) {

  barplotgg(metrics, ylab = x, xlab = "Sample.ID", colour_by = "Sample.ID",
            clean = 11, delim = "_", xdelim = ".", ydelim = ".",
            clean_label = clean_label)

  }, metrics = metrics, clean_label = wrap_label)
```

@fig-qcspot Plot all spot:

```{r}
#| fig.width: 12
#| fig.height: 4
#| label: fig-qcspot
#| fig-cap: Spot QC values.

wrap_plots(bars)
```

### Spot Filtering

#### Remove spots based on location

Sometimes there are regionally located clusters of low quality spots which may be filtered prior to downstream analysis. For example - the edges of slides which can be easily filtered as long as they are not clearly associated with a biological signal. This will need to be completed on a per sample basis - below is an example:

e.g. image at index 1

Look at ranges of x y values for easier estimation of coordinates

```{r}
#| eval: false

image_key <- seurat[[1]]@images[[1]]@key
  
# fetch xy axis data frame
spatial_df <- FetchData(seurat[[1]], vars = c(paste0(image_key, "imagerow"), 
                                         paste0(image_key, "imagecol")))

print(c("Y axis range:", range(spatial_df[,1])))
print(c("X axis range:",range(spatial_df[,2])))
```

Filter out those low quality spots which are located peripherally

```{r}
#| eval: false

seurat_1 <- filterByXY(seurat[[1]], x1 = 85.00408692 , x2 = 520 , 
                             y1 = 53.49836036, y2 = 513.829758624)
```

Show which cells have been filtered

```{r}
#| eval: false

labels <- SpatialDimPlot(seurat[[1]],cells.highlight = colnames(seurat_1))
```

Plot alongside original UMI count plot

```{r, message = FALSE, warning = FALSE}
#| eval: false
#| message: false
#| warning: false

counts <- SpatialFeaturePlot(seurat[[1]], features = "nCount_Spatial") + 
          theme(legend.position = "right")
```

Plot together

```{r, fig.width = 6, fig.height = 10}
#| eval: false
#| fig.width: 6
#| fig.height: 10

wrap_plots(counts, labels, ncol = 1)
```

Replace old seurat object with new

```{r}
#| eval: false

seurat[[1]] = NULL

seurat[[1]] = seurat_1
```

#### Remove spots with zero counts

SCT transform will complain when attempts to log transform - so we filter 0 count spots by default

Plot filtered spots

```{r}
wrap_plots(lapply(seurat, filterByPlot, threshold = 0, by = "nCount_Spatial", 
                  direction = "up"))
```

```{r}
seurat <- lapply(seurat, filterBy, threshold = 0, by = "nCount_Spatial", 
                 direction = "up")
```

## Output

Save experiment object:

```{r}
saveRDS(seurat, file = "output/02-quality-control.rds")
```

Print session information:

```{r}
sessionInfo()
```
